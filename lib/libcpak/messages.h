/*  messages.h - Messages generated by libcpak.
    
    Copyright 2013  Francisco Jose Monaco   <monaco.fj@gmail.com>

    This file is part of Libcpak. 

    Libcpak is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Libcpak is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with .  If not, see <http://www.gnu.org/licenses/>. 

*/

#ifndef _CPAK_MESSAGES_H
#define _CPAK_MESSAGES_H

#include <errno.h>
#include <string.h>

/* 
   Macros controlling behavior of error reporting functions.
*/

/* Whether cpak_sysfault will call exit or not. */
#ifndef CPAK_SYSFAULT_FATAL
#define CPAK_SYSFAULT_FATAL CPAK_TRUE	
#endif

/* Whether cpak_assert will be compiled or not. */
#ifndef CPAK_ASSERT
#define CPAK_ASSERT CPAK_TRUE
#endif
#ifndef CPAK_ASSERT_FATAL	/* Whether it will call exit or not. */
#define CPAK_ASSERT_FATAL CPAK_TRUE	
#endif

/* Whether cpak_verify will call exit or return. */
#ifndef CPAK_VERIFY_FATAL
#define CPAK_VERIFY_FATAL CPAK_TRUE	
#endif

/* 
   If HAD_DEVMODE==1, all error checks are nonfatal.  
*/

#if CPAK_DEVMODE==1
#undef CPAK_SYSFAULT_FATAL
#undef CPAK_ASSERT
#undef CPAK_ASSERT_FATAL
#undef CPAK_VERIFY_FATAL
#define CPAK_SYSFAULT_FATAL CPAK_FALSE
#define CPAK_ASSERT CPAK_TRUE
#define CPAK_ASSERT_FATAL HAL_FALSE
#define CPAK_VERIFY_FATAL CPAK_FALSE
#endif


/* Empty string if some logging symbol is NULL */

#define cpak_symbol_string(type) (cpak_engine.symbol_ ## type ? cpak_engine.symbol_ ## type : "")

/* Provision for gettext (not currently implemented) 
   It should be #define _(string) gettext(string) if HAVE_GETTEXT==1 
*/

#define _(string) string

/* 
   Libcpak sysfault: check and report system faults (syscall faults).
  
   If 'expression' is true, report error messagem conforming errno variable,
   and optionally exit with EXIT_FAILURE.
 */

/* Fatal. */
#define cpak_sysfault_fatal(expression) do{ if (expression) {fprintf (cpak_engine.sysfault_stream, "%s%s: %s: %d: %s\n", cpak_symbol_string(sysfault),cpak_engine.program_name, __FILE__, __LINE__, strerror(errno)); exit (EXIT_FAILURE);}}while(0)

/* Non-fatal.. */
#define cpak_sysfault_nonfatal(expression) do{ if (expression) {fprintf (cpak_engine.sysfault_stream, "%s%s: %s: %d: %s\n", cpak_symbol_string(sysfault), cpak_engine.program_name, __FILE__, __LINE__, strerror(errno));}}while(0)

/* System fault: fatal if CPAK_SYSFATAL is defined; non-fatal oterwise. 
   CPAK_SYSFATAL is true by default. */

#if (CPAK_SYSFAULT_FATAL != CPAK_FALSE) 
#define cpak_sysfault(expression) cpak_sysfault_fatal(expression)
#else
#define cpak_sysfault(expression) cpak_sysfault_nonfatal(expression)
#endif	/* CPAK_SYSFATAL */



/* Values of cpak_engine.errno
   Similar to errno from errno.h, but specific for cpak functions.*/

typedef enum
  {
    cpak_verify_ok,                      /* Success.*/
    cpak_verify_fault,		         /* Unspecified fault. */
    cpak_verify_invalid_argument	 /* Invalid argument. */
  } cpak_verify_code_t;

extern const char* cpak_error_messages[]; /* Strings for cpak error codes. */

#define _cpak_set_error(error_code) do{cpak_engine.error = error_code;}while(0)

/* Log symbols: used by test macros bellow. */

typedef enum 
  {
    cpak_symbol_log,	
    cpak_symbol_sysfault,
    cpak_symbol_verify,
    cpak_symbol_assert,
    cpak_symbol_check
  } cpak_symbol_t;

extern const char* cpak_symbols[]; 


/* 
  Libcpak verify: check for conditions prone to cause either runtime faults
  or incorrect results.  These may include calling a function with invalid 
  parameters (e.g. passing NULL to strdup), freeing a non-allocated memory 
  block (e.g. if using cpak_malloc), and so on.

  If 'expression' is true, report a specific 'error_message' and either return
  with a given 'return_value', or exit with EXIT_FAILURE.

 */

/* Exit on fault. */
#define cpak_verify_fatal(expression, error_code) do{_cpak_set_error(cpak_verify_ok); if (expression) {_cpak_set_error(cpak_verify_fault); fprintf (cpak_engine.verify_stream, "%s%s: %s: %d: %s\n", cpak_symbol_string(verify), cpak_engine.program_name, __FILE__, __LINE__, cpak_error_messages[error_code]); exit (EXIT_FAILURE);}}while(0)

/* Don't exit. */
#define cpak_verify_nonfatal(expression, error_code, return_value) do{_cpak_set_error(cpak_verify_ok); if (expression) {_cpak_set_error(cpak_verify_fault); fprintf (cpak_engine.verify_stream, "%s%s: %s: %d: %s\n", cpak_symbol_string(verify), cpak_engine.program_name, __FILE__, __LINE__, cpak_error_messages[error_code]); return return_value;}}while(0)

/* Libcpak verify: fatal if CPAK_FATAL is defined; non-fatal otherwise. */

#if (CPAK_VERIFY_FATAL != CPAK_FALSE) 
#define cpak_verify(expression, code, value) cpak_verify_fatal(expression, code)
#else
#define cpak_verify(expression, code, value) cpak_verify_nonfatal(expression, code, value)
#endif	/* CPAK_VERIFY_FATAL */



/* 
   cpak_assert: conditions that should never happen. It's a bug.

   If 'expression' is true, exhibit the asserted condition (the stringfied expression)
   and a customized 'error_message', if non NULL.  
 */

/* Exit on fault. */
#define cpak_assert_fatal(expression, error_message) do{if (expression) {fprintf (cpak_engine.assert_stream, "%s%s: %s: %d: %s %s\n", cpak_symbol_string(assert), cpak_engine.program_name, __FILE__, __LINE__, #expression, error_message ? error_message : ""); exit (EXIT_FAILURE);}}while(0)

/* Dont exit. */
#define cpak_assert_nonfatal(expression, error_message) do{ if (expression) {fprintf (cpak_engine.assert_stream, "%s%s: %s: %d: %s %s\n", cpak_symbol_string(assert), cpak_engine.program_name, __FILE__, __LINE__, #expression, error_message ? error_message : "");}}while(0)

/* Libcpak assert: fatal if CPAK_FATAL is defined; nonfatal otherwise. */
   
#if (CPAK_ASSERT_FATAL != CPAK_FALSE)
#define cpak_assert(expression, message) cpak_assert_fatal(expression, message)
#else
#define cpak_assert(expression, message) cpak_assert_nonfatal(expression, message)
#endif	/* CPAK_FATAL */

#if (CPAK_ASSERT == CPAK_FALSE)
#undef cpak_assert_fatal
#undef cpak_assert_nonfatal
#undef cpak_assert
#define cpak_assert_fatal(expression, errror) while(0)
#define cpak_assert_nonfatal(expression, errror) while(0)
#define cpak_assert(expression, errror) while(0)
#endif



/* 
  Libcpak check: user customized checks.

  If 'expression' is true, report a specific 'error_message' and either return
  with a given 'return_value', or exit with EXIT_FAILURE.

 */

/* Exit on fault. */
#define cpak_check_fatal(expression, error_message) do{ if (expression) {fprintf (cpak_engine.assert_stream, "%s%s: %s: %d: %s\n", cpak_symbol_string(check), cpak_engine.program_name, __FILE__, __LINE__, error_message ? _(error_message) : ""); exit (EXIT_FAILURE);}}while(0)

/* Return on fault. */
#define cpak_check_nonfatal(expression, error_message, return_value) do{ if (expression) {fprintf (cpak_engine.assert_stream, "%s%s: %s: %d: %s\n", cpak_symbol_string(check), cpak_engine.program_name, __FILE__, __LINE__, error_message ? _(error_message): ""); return return_value;}}while(0)


/* Libcpak log: general log messages (variable arguments) */
int cpak_log (const char *, ...);

/* Missing system functions replaced by autoconf. */
extern const char *cpak_replaced;	

#endif /* _CPAK_MESSAGES_H */


